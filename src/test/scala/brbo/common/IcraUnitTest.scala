package brbo.common

import brbo.TestCase
import brbo.common.TypeUtils.BrboType._
import brbo.common.icra.{Icra, IcraLexer, IcraParser}
import org.apache.logging.log4j.LogManager
import org.scalatest.flatspec.AnyFlatSpec

import scala.collection.immutable.HashSet

class IcraUnitTest extends AnyFlatSpec {
  private val logger = LogManager.getLogger(classOf[IcraUnitTest])

  "Parser" should "correctly parse boolean expressions from ICRA's outputs (unit tests)" in {
    IcraUnitTest.parserUnitTestBoolExpressions.foreach({
      testCase =>
        val expression = IcraParser.parseBoolExpression(testCase.input)
        logger.debug(expression)
        assert(expression.toString == testCase.expectedOutput)
    })
  }

  it should "correctly parse arithmetic expressions from ICRA's outputs (unit tests)" in {
    IcraUnitTest.parserUnitTestArithmeticExpressions.foreach({
      testCase =>
        val expression = IcraParser.parseArithmeticExpression(testCase.input)
        logger.debug(expression)
        assert(expression.toString == testCase.expectedOutput)
    })
  }

  it should "correctly parse boolean expressions from ICRA's outputs (integration tests)" in {
    IcraUnitTest.parserIntegrationTestBoolExpressions.foreach({
      testCase =>
        val expression = IcraParser.parseBoolExpression(testCase.input)
        logger.debug(expression)
        assert(expression.toString == testCase.expectedOutput)
    })
  }

  "Icra parser" should "correctly extract raw invariants from ICRA's outputs" in {
    IcraUnitTest.parseIcraOutputRawInvariant.foreach({
      testCase =>
        val parser = new IcraParser(testCase.input)
        val invariants = parser.extractRawInvariants
        logger.debug(invariants.mkString("\n"))
        assert(invariants.size == 1)
        assert(invariants.head.toString == testCase.expectedOutput)
    })
  }

  it should "correctly apply a lexer on ICRA's outputs" in {
    IcraUnitTest.parseIcraOutputLexer.foreach({
      testCase =>
        val parser = new IcraParser(testCase.input)
        val rawInvariants = parser.extractRawInvariants
        assert(rawInvariants.size == 1)
        val rawInvariant = rawInvariants.head
        val declarations = IcraLexer.parse(rawInvariant.declarations)
        logger.debug(declarations)
        val invariant = IcraLexer.parse(rawInvariant.invariant)
        logger.debug(invariant)
        assert(s"$declarations\n$invariant" == testCase.expectedOutput)
    })
  }

  it should "correctly apply a parser on ICRA's outputs" in {
    IcraUnitTest.parseIcraOutputParser.foreach({
      testCase =>
        val parser = new IcraParser(testCase.input)
        val rawInvariants = parser.extractRawInvariants
        assert(rawInvariants.size == 1)
        val rawInvariant = rawInvariants.head
        val declarations = IcraParser.parseDeclarations(rawInvariant.declarations)
        logger.debug(declarations)
        val invariant = IcraParser.parseInvariant(rawInvariant.invariant)
        logger.debug(invariant)
        assert(s"$declarations\n$invariant" == testCase.expectedOutput)
    })
  }

  it should "correctly generate Z3 AST from IcraAST (integer-typed)" in {
    IcraUnitTest.generateZ3ASTIntegerUnitTest.foreach({
      testCase =>
        val expression = IcraParser.parseBoolExpression(testCase.input)
        val solver = new Z3Solver
        val z3Ast = Icra.translateToZ3(expression, INT, solver)
        logger.debug(z3Ast)
        assert(z3Ast.toString == testCase.expectedOutput)
    })
  }

  it should "correctly generate Z3 AST from IcraAST (boolean-typed)" in {
    IcraUnitTest.generateZ3ASTBoolUnitTest.foreach({
      testCase =>
        val expression = IcraParser.parseBoolExpression(testCase.input)
        val solver = new Z3Solver
        val z3Ast = Icra.translateToZ3(expression, BOOL, solver)
        logger.debug(z3Ast)
        assert(z3Ast.toString == testCase.expectedOutput)
    })
  }
}

object IcraUnitTest {
  private val unitIdentifier = "j':99"

  private val unitNumber = "145875"

  private val unitBracket = "(D100':92)"

  private val unitNegation = "!D100':92"

  private val unitNegative = "-D100':92"

  private val unitAddition = "1 + i':92"

  private val unitSubtraction = "K:91 - i':92"

  private val unitMultiplication = "K:91 * i':92"

  private val unitDivision = "K:91 / i':92"

  private val unitLessThan = "K:91 < i':92"

  private val unitLessThanOrEqualTo = "K:91 <= i':92"

  private val unitGreaterThan = "K:91 > i':92"

  private val unitGreaterThanOrEqualTo = "K:91 >= i':92"

  private val unitEqual = "K:91 = i':92"

  private val unitEqual2 = "K:91 = -i':92"

  private val unitAnd = """K:91 /\ i':92"""

  private val unitOr = """K:91 \/ i':92"""

  private val unitIte = """ite(K:240 = 0, 1, 0)"""

  private val integrationTest1 = """((0 <= K:97 /\ K:97 <= 0))"""

  private val integrationTest2 = """!((0 <= K:97 /\ K:97 <= 0))"""

  private val integrationTest3 = """(!((0 <= K:97 /\ K:97 <= 0)) \/ (D100':98 + -j':99) = -j:2)"""

  private val integrationTest4 = """(!(1 <= K:97) \/ (D100':98 + -j':99) = 0)"""

  private val integrationTest5 = """(K:97 = 0 /\ j:2 = j':99 /\ 0 = D100':98)"""

  private val integrationTest6 = """1 <= K:97 /\ 0 <= (-1 + param0:15)"""

  private val integrationTest7 = """(-j':99 + D100':98) = 0 /\ 0 <= (-1 + param0:15)                     /\ 0 <= (j':99 + -param1:18) /\ 0 <= j':99"""

  private val integrationTest8 = """0 <= K:97 /\ 0 <= D100':98 /\ 0 < param0:15"""

  private val integrationTest9 = """((D100':98 + -j':99) = -j:2)"""

  private val integrationTest10 = """(i:0 < n:1
                                    |         /\ ((0 <= m:4 /\ ite(D100:3 <= m:4, 1, 0) = phi_tmp:26)
                                    |               \/ (m:4 < 0 /\ 1 = phi_tmp:26)))""".stripMargin

  private val test01 =
    """<Unique State Name, 38> -> <Unique State Name, 37>      Base relation: {when cond:48 = 0}       <Unique State Name, 38> -> <Unique State Name, 39>      Base relation: {when !(cond:48 = 0)}    <Unique State Name, 9> -> <Unique State Name, 14>   Base relation: {j := 0 when i:0 < n:1}  <Unique State Name, 9> -> <Unique State Name, 60>       Base relation: {return := havoc:16 return@pos := type_err:17 return@width := type_err:18 when n:1 <= i:0}       <Unique State Name, 5> -> <Unique State Name, 62>   Base relation: {when (D100:4 = 0 /\ 0 <= i:0 /\ D100:4 = 0)}    <Unique State Name, 60> -> <Unique State Name, >        Base relation: {}       <Unique State Name, 46> -> <Unique State Name, 48>  Base relation: {when false}     <Unique State Name, 55> -> <Unique State Name, 38>      Base relation: {cond := param0:12}      <Unique State Name, 54> -> <Unique State Name, 47>      Base relation: {cond := param0:12}  <Unique State Name, 56> -> <Unique State Name, 5>       Base relation: {D100 := 0 i := 0 n := param0:12 m := param1:15} <Unique State Name, 47> -> <Unique State Name, 46>      Base relation: {when cond:58 = 0}       <Unique State Name, 47> -> <Unique State Name, 48>  Base relation: {when !(cond:58 = 0)}    <Unique State Name, 37> -> <Unique State Name, 39>      Base relation: {when false}     <Unique State Name, 14> -> <Unique State Name, 61> Base relation: {when (0 <= D100:4 /\ 0 <= j:2 /\ (-j:2 + D100:4) = 0)}   <Unique State Name, 39> -> <Unique State Name, 59>      Base relation: {return := havoc:49 return@pos := type_err:52 return@width := type_err:53}       <Unique State Name, 48> -> <Unique State Name, 58>  Base relation: {return := havoc:59 return@pos := type_err:62 return@width := type_err:63}       <Unique State Name, 61> -> <Unique State Name, 18>      Base relation: {}       <Unique State Name, 62> -> <Unique State Name, 9>   Base relation: {}       <Unique State Name, 29> -> <Unique State Name, 5>       Base relation: {}       <Unique State Name, 18> -> <Unique State Name, 14>      Base relation: {D100 := (D100:4 + 1) j := (j:2 + 1) when j:2 < m:3} <Unique State Name, 18> -> <Unique State Name, 29>      Base relation: {D100 := 0 i := (i:0 + 1) when m:3 <= j:2}       #################################################################           Beginning Interprocedural Anaylsis (with regexp=IRE)  Step 1: =========================================================Step 2: =========================================================Step 3: =========================================================        Converting to IRE regular expressions(Not performing widening.)alphaHatStar {**** body value: Base relation: {D100 := (D100:4 + 1) j := (j:2 + 1) when (0 <= D100:4 /\ 0 <= j:2 /\ (-j:2 + D100:4) = 0 /\ j:2 < m:3)}**** alpha hat:   {(j':69) = (1)*(j:2) + 1    (D100':68) = (1)*(j:2) + 1        pre:      [|-j:2+D100:4=0; -j:2+m:3-1>=0; j:2>=0|]    post:      [|-D100':68+j':69=0; -D100':68+m:3>=0; D100':68-1>=0|]}**** star transition:   {D100 := D100':68   j := j':69   when ((!(0 <= K:75) \/ j':69 = (j:2 + K:75))           /\ (!((0 <= K:75 /\ K:75 <= 0)) \/ D100':68 = (D100:4 + K:75))           /\ (!(1 <= K:75) \/ D100':68 = (j:2 + K:75))           /\ ((K:75 = 0 /\ j:2 = j':69 /\ D100:4 = D100':68)                 \/ (1 <= K:75 /\ (-j:2 + D100:4) = 0                       /\ 0 <= (-1 + -j:2 + m:3) /\ 0 <= j:2                       /\ (-D100':68 + j':69) = 0 /\ 0 <= (-D100':68 + m:3)                       /\ 0 <= (-1 + D100':68))) /\ 0 <= K:75)}}(Not performing widening.)alphaHatStar {**** body value: Base relation: {D100 := 0 i := (i:0 + 1) j := j':80 when (D100:4 = 0 /\ 0 <= i:0 /\ D100:4 = 0 /\ i:0 < n:1         /\ (!(0 <= K:79) \/ j':80 = K:79)         /\ (!((0 <= K:79 /\ K:79 <= 0)) \/ D100':81 = (D100:4 + K:79))         /\ (!(1 <= K:79) \/ D100':81 = K:79)         /\ ((K:79 = 0 /\ 0 = j':80 /\ D100:4 = D100':81)               \/ (1 <= K:79 /\ D100:4 = 0 /\ 0 <= (-1 + m:3)                     /\ (-D100':81 + j':80) = 0 /\ 0 <= (-D100':81 + m:3)                     /\ 0 <= (-1 + D100':81))) /\ 0 <= K:79 /\ 0 <= D100':81         /\ 0 <= j':80 /\ (-j':80 + D100':81) = 0 /\ m:3 <= j':80)}**** alpha hat:   {(D100':68) = 0    (i':82) = (1)*(i:0) + 1        pre:      [|D100:4=0; -i:0+n:1-1>=0; i:0>=0|]    post:      [|D100':68=0; -i':82+n:1>=0; j':69-m:3>=0; j':69>=0; i':82-1>=0|]}**** star transition:   {D100 := D100':68   i := i':82   j := j':69   when ((!((0 <= K:90 /\ K:90 <= 0)) \/ D100':68 = D100:4)           /\ (!(1 <= K:90) \/ D100':68 = 0)           /\ (!(0 <= K:90) \/ i':82 = (i:0 + K:90))           /\ ((K:90 = 0 /\ j:2 = j':69 /\ i:0 = i':82 /\ D100:4 = D100':68)                 \/ (1 <= K:90 /\ D100:4 = 0 /\ 0 <= (-1 + -i:0 + n:1)                       /\ 0 <= i:0 /\ D100':68 = 0 /\ 0 <= (-i':82 + n:1)                       /\ 0 <= (j':69 + -m:3) /\ 0 <= j':69                       /\ 0 <= (-1 + i':82))) /\ 0 <= K:90)}}Step 4: =========================================================The procedure (i.e., variable) numbers are: 7  New-style (IRE) regular expression in IREregExpMap for reID=7: Weight(Base relation:   {D100 := D100':92   i := i':93   j := j':94   n := param0:12   m := param1:15   return := havoc:104   return@pos := type_err:105   return@width := type_err:106   when ((!((0 <= K:91 /\ K:91 <= 0)) \/ D100':92 = 0)           /\ (!(1 <= K:91) \/ D100':92 = 0)           /\ (!(0 <= K:91) \/ i':93 = K:91)           /\ ((K:91 = 0 /\ j:2 = j':94 /\ 0 = i':93 /\ 0 = D100':92)                 \/ (1 <= K:91 /\ 0 <= (-1 + param0:12) /\ D100':92 = 0                       /\ 0 <= (-i':93 + param0:12)                       /\ 0 <= (j':94 + -param1:15) /\ 0 <= j':94                       /\ 0 <= (-1 + i':93))) /\ 0 <= K:91 /\ D100':92 = 0           /\ 0 <= i':93 /\ D100':92 = 0 /\ param0:12 <= i':93)})Performing Gaussian Elimination.  ------------------------------ Working on variable 7  New-style (IRE) regular expression for 7 just before isolating it: Weight(Base relation:   {return := havoc:104   return@pos := type_err:105   return@width := type_err:106   when ((!((0 <= K:91 /\ K:91 <= 0)) \/ D100':92 = 0)           /\ (!(1 <= K:91) \/ D100':92 = 0)           /\ (!(0 <= K:91) \/ i':93 = K:91)           /\ ((K:91 = 0 /\ j:107 = j':94 /\ 0 = i':93 /\ 0 = D100':92)                 \/ (1 <= K:91 /\ 0 <= (-1 + param0:12) /\ D100':92 = 0                       /\ 0 <= (-i':93 + param0:12)                       /\ 0 <= (j':94 + -param1:15) /\ 0 <= j':94                       /\ 0 <= (-1 + i':93))) /\ 0 <= K:91 /\ D100':92 = 0           /\ 0 <= i':93 /\ D100':92 = 0 /\ param0:12 <= i':93)}) ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  Finished Gaussian Elimination.New-style (IRE) regular expression in IREregExpsAfterIsolation for reID=7: Weight(Base relation:   {return := havoc:104   return@pos := type_err:105   return@width := type_err:106   when ((!((0 <= K:91 /\ K:91 <= 0)) \/ D100':92 = 0)           /\ (!(1 <= K:91) \/ D100':92 = 0)           /\ (!(0 <= K:91) \/ i':93 = K:91)           /\ ((K:91 = 0 /\ j:107 = j':94 /\ 0 = i':93 /\ 0 = D100':92)                 \/ (1 <= K:91 /\ 0 <= (-1 + param0:12) /\ D100':92 = 0                       /\ 0 <= (-i':93 + param0:12)                       /\ 0 <= (j':94 + -param1:15) /\ 0 <= j':94                       /\ 0 <= (-1 + i':93))) /\ 0 <= K:91 /\ D100':92 = 0           /\ 0 <= i':93 /\ D100':92 = 0 /\ param0:12 <= i':93)})Step 5: =========================================================[Newton] Running Newton-------------------------------------------------------------------------------Round 0:Evaluating variable number 7 (using IRE)   The IRE-evaluated value on this round is: Base relation: {return := havoc:104 return@pos := type_err:105 return@width := type_err:106 when ((!((0 <= K:91 /\ K:91 <= 0)) \/ D100':92 = 0)         /\ (!(1 <= K:91) \/ D100':92 = 0) /\ (!(0 <= K:91) \/ i':93 = K:91)         /\ ((K:91 = 0 /\ j:107 = j':94 /\ 0 = i':93 /\ 0 = D100':92)               \/ (1 <= K:91 /\ 0 <= (-1 + param0:12) /\ D100':92 = 0                     /\ 0 <= (-i':93 + param0:12)                     /\ 0 <= (j':94 + -param1:15) /\ 0 <= j':94                     /\ 0 <= (-1 + i':93))) /\ 0 <= K:91 /\ D100':92 = 0         /\ 0 <= i':93 /\ D100':92 = 0 /\ param0:12 <= i':93)}    (IRE-tc) Checking termination condition.    (IRE-tc)     >> All star bodies equivalent.NumRnds: 1Step 6: =========================================================##### Question automaton as FWPDS##### QUERY2WFA -  Initial State : __pstate  Q: {__pstate, __done}  F: {__done}    ( __pstate , accept , __done )     Base relation: {}Weights on states: __pstate 0x55d5ca7d12b0:    Weight: Base relation: {when false} Accept: Base relation: {when false}__done 0x55d5ca7d10c0:       Weight: Base relation: {when false}     Accept: Base relation: {}##### ANSWFA -  Initial State : __pstate  Q: {__pstate, __done}  F: {__done}    ( __pstate , accept , __done )     Base relation: {}Weights on states: __pstate 0x55d5ca7d0ed0:    Weight: Base relation: {when false}     Accept: Base relation: {when false}__done 0x55d5ca7d0bd0:       Weight: Base relation: {when false} Accept: Base relation: {}================================================Procedure Summaries------------------------------------------------Procedure summary for mainBase relation: {D100 := D100':92 i := i':93 j := j':94 n := param0:12 m := param1:15 return := havoc:104 return@pos := type_err:105 return@width := type_err:106 when ((!((0 <= K:91 /\ K:91 <= 0)) \/ D100':92 = 0)         /\ (!(1 <= K:91) \/ D100':92 = 0) /\ (!(0 <= K:91) \/ i':93 = K:91)         /\ ((K:91 = 0 /\ j:2 = j':94 /\ 0 = i':93 /\ 0 = D100':92)               \/ (1 <= K:91 /\ 0 <= (-1 + param0:12) /\ D100':92 = 0                     /\ 0 <= (-i':93 + param0:12)                     /\ 0 <= (j':94 + -param1:15) /\ 0 <= j':94                     /\ 0 <= (-1 + i':93))) /\ 0 <= K:91 /\ D100':92 = 0         /\ 0 <= i':93 /\ D100':92 = 0 /\ param0:12 <= i':93)}================================================Assertion Checking at Error PointsChecking assertion at vertex 9, line 35Base relation: {when false}contextWeight = Base relation: {}intraproceduralWeight = Base relation: {D100 := 0 i := (i':93 + 1) j := j':96 n := param0:12 m := param1:15 when ((!((0 <= K:91 /\ K:91 <= 0)) \/ D100':92 = 0)         /\ (!(1 <= K:91) \/ D100':92 = 0) /\ (!(0 <= K:91) \/ i':93 = K:91)         /\ ((K:91 = 0 /\ j:2 = j':94 /\ 0 = i':93 /\ 0 = D100':92)               \/ (1 <= K:91 /\ 0 <= (-1 + param0:12) /\ D100':92 = 0                     /\ 0 <= (-i':93 + param0:12)                     /\ 0 <= (j':94 + -param1:15) /\ 0 <= j':94                     /\ 0 <= (-1 + i':93))) /\ 0 <= K:91 /\ D100':92 = 0         /\ 0 <= i':93 /\ D100':92 = 0 /\ i':93 < param0:12         /\ (!(0 <= K:95) \/ j':96 = K:95)         /\ (!((0 <= K:95 /\ K:95 <= 0)) \/ D100':97 = (D100':92 + K:95))         /\ (!(1 <= K:95) \/ D100':97 = K:95)         /\ ((K:95 = 0 /\ 0 = j':96 /\ D100':92 = D100':97)               \/ (1 <= K:95 /\ D100':92 = 0 /\ 0 <= (-1 + param1:15)                     /\ (-D100':97 + j':96) = 0                     /\ 0 <= (-D100':97 + param1:15) /\ 0 <= (-1 + D100':97)))         /\ 0 <= K:95 /\ 0 <= D100':97 /\ 0 <= j':96         /\ (-j':96 + D100':97) = 0 /\ param1:15 <= j':96)}*******************************************(declare-const j Int)(declare-const |D100'0| Int)(declare-const K Int)(declare-const |j'0| Int)(declare-const param1 Int)(declare-const |i'| Int)(declare-const K0 Int)(declare-const |j'| Int)(declare-const param0 Int)(declare-const |D100'| Int)(assert (and (or (not (and (<= 0 K) (<= K 0))) (= |D100'| 0))               (or (not (<= 1 K)) (= |D100'| 0))               (or (not (<= 0 K)) (= |i'| K))               (or (and (= K 0) (= j |j'|) (= 0 |i'|) (= 0 |D100'|))                     (and (<= 1 K) (<= 0 (+ -1 param0)) (= |D100'| 0)                            (<= 0 (+ (- |i'|) param0))                            (<= 0 (+ |j'| (- param1))) (<= 0 |j'|)                            (<= 0 (+ -1 |i'|)))) (<= 0 K) (= |D100'| 0)               (<= 0 |i'|) (= |D100'| 0) (< |i'| param0)               (or (not (<= 0 K0)) (= |j'0| K0))               (or (not (and (<= 0 K0) (<= K0 0)))                     (= |D100'0| (+ |D100'| K0)))               (or (not (<= 1 K0)) (= |D100'0| K0))               (or (and (= K0 0) (= 0 |j'0|) (= |D100'| |D100'0|))                     (and (<= 1 K0) (= |D100'| 0) (<= 0 (+ -1 param1))                            (= (+ (- |D100'0|) |j'0|) 0)                            (<= 0 (+ (- |D100'0|) param1))                            (<= 0 (+ -1 |D100'0|)))) (<= 0 K0)               (<= 0 |D100'0|) (<= 0 |j'0|) (= (+ (- |j'0|) |D100'0|) 0)               (<= param1 |j'0|)))(check-sat)contextWeight extend intraproceduralWeight = Base relation: {D100 := 0 i := (i':93 + 1) j := j':96 n := param0:12 m := param1:15 when ((!((0 <= K:91 /\ K:91 <= 0)) \/ D100':92 = 0)         /\ (!(1 <= K:91) \/ D100':92 = 0) /\ (!(0 <= K:91) \/ i':93 = K:91)         /\ ((K:91 = 0 /\ j:2 = j':94 /\ 0 = i':93 /\ 0 = D100':92)               \/ (1 <= K:91 /\ 0 <= (-1 + param0:12) /\ D100':92 = 0                     /\ 0 <= (-i':93 + param0:12)                     /\ 0 <= (j':94 + -param1:15) /\ 0 <= j':94                     /\ 0 <= (-1 + i':93))) /\ 0 <= K:91 /\ D100':92 = 0         /\ 0 <= i':93 /\ D100':92 = 0 /\ i':93 < param0:12         /\ (!(0 <= K:95) \/ j':96 = K:95)         /\ (!((0 <= K:95 /\ K:95 <= 0)) \/ D100':97 = (D100':92 + K:95))         /\ (!(1 <= K:95) \/ D100':97 = K:95)         /\ ((K:95 = 0 /\ 0 = j':96 /\ D100':92 = D100':97)               \/ (1 <= K:95 /\ D100':92 = 0 /\ 0 <= (-1 + param1:15)                     /\ (-D100':97 + j':96) = 0                     /\ 0 <= (-D100':97 + param1:15) /\ 0 <= (-1 + D100':97)))         /\ 0 <= K:95 /\ 0 <= D100':97 /\ 0 <= j':96         /\ (-j':96 + D100':97) = 0 /\ param1:15 <= j':96)}Is not SAT! (Assertion on line 35 PASSED)---------------------------------------------================================================Bounds on Variables================================================Finished!"""

  private val test02 =
    """<Unique State Name, 38> -> <Unique State Name, 37>      Base relation: {when cond:48 = 0}       <Unique State Name, 38> -> <Unique State Name, 39>      Base relation: {when !(cond:48 = 0)}    <Unique State Name, 9> -> <Unique State Name, 14>   Base relation: {D100 := 0 when i:0 < n:1}       <Unique State Name, 9> -> <Unique State Name, 60>       Base relation: {return := havoc:16 return@pos := type_err:17 return@width := type_err:18 when n:1 <= i:0}  <Unique State Name, 5> -> <Unique State Name, 62>        Base relation: {when (0 <= D100:4 /\ 0 <= i:0)} <Unique State Name, 60> -> <Unique State Name, >        Base relation: {}       <Unique State Name, 46> -> <Unique State Name, 48>  Base relation: {when false}     <Unique State Name, 55> -> <Unique State Name, 38>      Base relation: {cond := param0:12}      <Unique State Name, 54> -> <Unique State Name, 47>      Base relation: {cond := param0:12} <Unique State Name, 56> -> <Unique State Name, 5>        Base relation: {D100 := 0 i := 0 n := param0:12 m := param1:15} <Unique State Name, 47> -> <Unique State Name, 46>      Base relation: {when cond:58 = 0}       <Unique State Name, 47> -> <Unique State Name, 48>  Base relation: {when !(cond:58 = 0)}    <Unique State Name, 37> -> <Unique State Name, 39>      Base relation: {when false}     <Unique State Name, 14> -> <Unique State Name, 16>      Base relation: {j := 0}     <Unique State Name, 39> -> <Unique State Name, 59>      Base relation: {return := havoc:49 return@pos := type_err:52 return@width := type_err:53}       <Unique State Name, 48> -> <Unique State Name, 58> Base relation: {return := havoc:59 return@pos := type_err:62 return@width := type_err:63}        <Unique State Name, 16> -> <Unique State Name, 61>      Base relation: {when (0 <= D100:4 /\ 0 <= j:2 /\ (-j:2 + D100:4) = 0)}  <Unique State Name, 62> -> <Unique State Name, 9>   Base relation: {}       <Unique State Name, 20> -> <Unique State Name, 5>       Base relation: {i := (i:0 + 1) when m:3 <= j:2} <Unique State Name, 20> -> <Unique State Name, 16> Base relation: {D100 := (D100:4 + 1) j := (j:2 + 1) when j:2 < m:3}      <Unique State Name, 61> -> <Unique State Name, 20>      Base relation: {}       #################################################################           Beginning Interprocedural Anaylsis (with regexp=IRE)  Step 1: =========================================================Step 2: =========================================================Step 3: =========================================================        Converting to IRE regular expressions(Not performing widening.)alphaHatStar {**** body value: Base relation: {D100 := (D100:4 + 1) j := (j:2 + 1) when (0 <= D100:4 /\ 0 <= j:2 /\ (-j:2 + D100:4) = 0 /\ j:2 < m:3)}**** alpha hat:   {(j':69) = (1)*(j:2) + 1    (D100':68) = (1)*(j:2) + 1        pre:      [|-j:2+D100:4=0; -j:2+m:3-1>=0; j:2>=0|]    post:      [|-D100':68+j':69=0; -D100':68+m:3>=0; D100':68-1>=0|]}**** star transition:   {D100 := D100':68   j := j':69   when ((!(0 <= K:75) \/ j':69 = (j:2 + K:75))           /\ (!((0 <= K:75 /\ K:75 <= 0)) \/ D100':68 = (D100:4 + K:75))           /\ (!(1 <= K:75) \/ D100':68 = (j:2 + K:75))           /\ ((K:75 = 0 /\ j:2 = j':69 /\ D100:4 = D100':68)                 \/ (1 <= K:75 /\ (-j:2 + D100:4) = 0                       /\ 0 <= (-1 + -j:2 + m:3) /\ 0 <= j:2                       /\ (-D100':68 + j':69) = 0 /\ 0 <= (-D100':68 + m:3)                       /\ 0 <= (-1 + D100':68))) /\ 0 <= K:75)}}(Not performing widening.)alphaHatStar {**** body value: Base relation: {D100 := D100':81 i := (i:0 + 1) j := j':80 when (0 <= D100:4 /\ 0 <= i:0 /\ i:0 < n:1 /\ (!(0 <= K:79) \/ j':80 = K:79)         /\ (!((0 <= K:79 /\ K:79 <= 0)) \/ D100':81 = K:79)         /\ (!(1 <= K:79) \/ D100':81 = K:79)         /\ ((K:79 = 0 /\ 0 = j':80 /\ 0 = D100':81)               \/ (1 <= K:79 /\ 0 <= (-1 + m:3) /\ (-D100':81 + j':80) = 0                     /\ 0 <= (-D100':81 + m:3) /\ 0 <= (-1 + D100':81)))         /\ 0 <= K:79 /\ 0 <= D100':81 /\ 0 <= j':80         /\ (-j':80 + D100':81) = 0 /\ m:3 <= j':80)}**** alpha hat:   {(i':82) = (1)*(i:0) + 1    ((D100':68 + -j':69)) = 0        pre:      [|-i:0+n:1-1>=0; D100:4>=0; i:0>=0|]    post:      [|-j':69+D100':68=0; -i':82+n:1>=0; i':82-1>=0; j':69-m:3>=0; j':69>=0|]}**** star transition:   {D100 := D100':68   i := i':82   j := j':69   when ((!(0 <= K:90) \/ i':82 = (i:0 + K:90))           /\ (!((0 <= K:90 /\ K:90 <= 0))                 \/ (D100':68 + -j':69) = (D100:4 + -j:2))           /\ (!(1 <= K:90) \/ (D100':68 + -j':69) = 0)           /\ ((K:90 = 0 /\ j:2 = j':69 /\ i:0 = i':82 /\ D100:4 = D100':68)                 \/ (1 <= K:90 /\ 0 <= (-1 + -i:0 + n:1) /\ 0 <= D100:4                       /\ 0 <= i:0 /\ (-j':69 + D100':68) = 0                       /\ 0 <= (-i':82 + n:1) /\ 0 <= (-1 + i':82)                       /\ 0 <= (j':69 + -m:3) /\ 0 <= j':69)) /\ 0 <= K:90)}}Step 4: =========================================================The procedure (i.e., variable) numbers are: 7  New-style (IRE) regular expression in IREregExpMap for reID=7: Weight(Base relation:   {D100 := D100':93   i := i':92   j := j':94   n := param0:12   m := param1:15   return := havoc:101   return@pos := type_err:102   return@width := type_err:103   when ((!(0 <= K:91) \/ i':92 = K:91)           /\ (!((0 <= K:91 /\ K:91 <= 0)) \/ (D100':93 + -j':94) = -j:2)           /\ (!(1 <= K:91) \/ (D100':93 + -j':94) = 0)           /\ ((K:91 = 0 /\ j:2 = j':94 /\ 0 = i':92 /\ 0 = D100':93)                 \/ (1 <= K:91 /\ 0 <= (-1 + param0:12)                       /\ (-j':94 + D100':93) = 0                       /\ 0 <= (-i':92 + param0:12) /\ 0 <= (-1 + i':92)                       /\ 0 <= (j':94 + -param1:15) /\ 0 <= j':94))           /\ 0 <= K:91 /\ 0 <= D100':93 /\ 0 <= i':92 /\ param0:12 <= i':92)})Performing Gaussian Elimination.  ------------------------------ Working on variable 7  New-style (IRE) regular expression for 7 just before isolating it: Weight(Base relation:   {return := havoc:101   return@pos := type_err:102   return@width := type_err:103   when ((!(0 <= K:91) \/ i':92 = K:91)           /\ (!((0 <= K:91 /\ K:91 <= 0)) \/ (D100':93 + -j':94) = -j:104)           /\ (!(1 <= K:91) \/ (D100':93 + -j':94) = 0)           /\ ((K:91 = 0 /\ j:104 = j':94 /\ 0 = i':92 /\ 0 = D100':93)                 \/ (1 <= K:91 /\ 0 <= (-1 + param0:12)                       /\ (-j':94 + D100':93) = 0                       /\ 0 <= (-i':92 + param0:12) /\ 0 <= (-1 + i':92)                       /\ 0 <= (j':94 + -param1:15) /\ 0 <= j':94))           /\ 0 <= K:91 /\ 0 <= D100':93 /\ 0 <= i':92 /\ param0:12 <= i':92)}) ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  Finished Gaussian Elimination.New-style (IRE) regular expression in IREregExpsAfterIsolation for reID=7: Weight(Base relation:   {return := havoc:101   return@pos := type_err:102   return@width := type_err:103   when ((!(0 <= K:91) \/ i':92 = K:91)           /\ (!((0 <= K:91 /\ K:91 <= 0)) \/ (D100':93 + -j':94) = -j:104)           /\ (!(1 <= K:91) \/ (D100':93 + -j':94) = 0)           /\ ((K:91 = 0 /\ j:104 = j':94 /\ 0 = i':92 /\ 0 = D100':93)                 \/ (1 <= K:91 /\ 0 <= (-1 + param0:12)                       /\ (-j':94 + D100':93) = 0                       /\ 0 <= (-i':92 + param0:12) /\ 0 <= (-1 + i':92)                       /\ 0 <= (j':94 + -param1:15) /\ 0 <= j':94))           /\ 0 <= K:91 /\ 0 <= D100':93 /\ 0 <= i':92 /\ param0:12 <= i':92)})Step 5: =========================================================[Newton] Running Newton-------------------------------------------------------------------------------Round 0:Evaluating variable number 7 (using IRE)   The IRE-evaluated value on this round is: Base relation: {return := havoc:101 return@pos := type_err:102 return@width := type_err:103 when ((!(0 <= K:91) \/ i':92 = K:91)         /\ (!((0 <= K:91 /\ K:91 <= 0)) \/ (D100':93 + -j':94) = -j:104)         /\ (!(1 <= K:91) \/ (D100':93 + -j':94) = 0)         /\ ((K:91 = 0 /\ j:104 = j':94 /\ 0 = i':92 /\ 0 = D100':93)               \/ (1 <= K:91 /\ 0 <= (-1 + param0:12)                     /\ (-j':94 + D100':93) = 0 /\ 0 <= (-i':92 + param0:12)                     /\ 0 <= (-1 + i':92) /\ 0 <= (j':94 + -param1:15)                     /\ 0 <= j':94)) /\ 0 <= K:91 /\ 0 <= D100':93         /\ 0 <= i':92 /\ param0:12 <= i':92)}    (IRE-tc) Checking termination condition.    (IRE-tc)     >> All star bodies equivalent.NumRnds: 1Step 6: =========================================================##### Question automaton as FWPDS##### QUERY2WFA -  Initial State : __pstate  Q: {__pstate, __done}  F: {__done}    ( __pstate , accept , __done ) Base relation: {}Weights on states: __pstate 0x55748a886f00:    Weight: Base relation: {when false}     Accept: Base relation: {when false}__done 0x55748a8bdc40:       Weight: Base relation: {when false}Accept: Base relation: {}##### ANSWFA -  Initial State : __pstate  Q: {__pstate, __done}  F: {__done}    ( __pstate , accept , __done )  Base relation: {}Weights on states: __pstate 0x55748a794aa0:    Weight: Base relation: {when false} Accept: Base relation: {when false}__done 0x55748a8743e0:       Weight: Base relation: {when false}     Accept: Base relation: {}================================================Procedure Summaries------------------------------------------------Procedure summary for mainBase relation: {D100 := D100':93 i := i':92 j := j':94 n := param0:12 m := param1:15 return := havoc:101 return@pos := type_err:102 return@width := type_err:103 when ((!(0 <= K:91) \/ i':92 = K:91)         /\ (!((0 <= K:91 /\ K:91 <= 0)) \/ (D100':93 + -j':94) = -j:2)         /\ (!(1 <= K:91) \/ (D100':93 + -j':94) = 0)         /\ ((K:91 = 0 /\ j:2 = j':94 /\ 0 = i':92 /\ 0 = D100':93)               \/ (1 <= K:91 /\ 0 <= (-1 + param0:12)                     /\ (-j':94 + D100':93) = 0 /\ 0 <= (-i':92 + param0:12)                     /\ 0 <= (-1 + i':92) /\ 0 <= (j':94 + -param1:15)                     /\ 0 <= j':94)) /\ 0 <= K:91 /\ 0 <= D100':93         /\ 0 <= i':92 /\ param0:12 <= i':92)}================================================Assertion Checking at Error PointsChecking assertion at vertex 5, line 26Base relation: {when false}contextWeight = Base relation: {}intraproceduralWeight = Base relation: {D100 := 0 i := i':92 j := j':94 n := param0:12 m := param1:15 when ((!(0 <= K:91) \/ i':92 = K:91)         /\ (!((0 <= K:91 /\ K:91 <= 0)) \/ (D100':93 + -j':94) = -j:2)         /\ (!(1 <= K:91) \/ (D100':93 + -j':94) = 0)         /\ ((K:91 = 0 /\ j:2 = j':94 /\ 0 = i':92 /\ 0 = D100':93)               \/ (1 <= K:91 /\ 0 <= (-1 + param0:12)                     /\ (-j':94 + D100':93) = 0 /\ 0 <= (-i':92 + param0:12)                     /\ 0 <= (-1 + i':92) /\ 0 <= (j':94 + -param1:15)                     /\ 0 <= j':94)) /\ 0 <= K:91 /\ 0 <= D100':93         /\ 0 <= i':92 /\ i':92 < param0:12)}*******************************************(declare-const j Int)(declare-const K Int)(declare-const param1 Int)(declare-const |D100'| Int)(declare-const |j'| Int)(declare-const param0 Int)(declare-const |i'| Int)(assert (and (or (not (<= 0 K)) (= |i'| K))               (or (not (and (<= 0 K) (<= K 0)))                     (= (+ |D100'| (- |j'|)) (- j)))               (or (not (<= 1 K)) (= (+ |D100'| (- |j'|)) 0))               (or (and (= K 0) (= j |j'|) (= 0 |i'|) (= 0 |D100'|))                     (and (<= 1 K) (<= 0 (+ -1 param0))                            (= (+ (- |j'|) |D100'|) 0)                            (<= 0 (+ (- |i'|) param0)) (<= 0 (+ -1 |i'|))                            (<= 0 (+ |j'| (- param1))) (<= 0 |j'|))) (<=                0 K) (<= 0 |D100'|) (<= 0 |i'|) (< |i'| param0)))(check-sat)contextWeight extend intraproceduralWeight = Base relation: {D100 := 0 i := i':92 j := j':94 n := param0:12 m := param1:15 when ((!(0 <= K:91) \/ i':92 = K:91)         /\ (!((0 <= K:91 /\ K:91 <= 0)) \/ (D100':93 + -j':94) = -j:2)         /\ (!(1 <= K:91) \/ (D100':93 + -j':94) = 0)         /\ ((K:91 = 0 /\ j:2 = j':94 /\ 0 = i':92 /\ 0 = D100':93)               \/ (1 <= K:91 /\ 0 <= (-1 + param0:12)                     /\ (-j':94 + D100':93) = 0 /\ 0 <= (-i':92 + param0:12)                     /\ 0 <= (-1 + i':92) /\ 0 <= (j':94 + -param1:15)                     /\ 0 <= j':94)) /\ 0 <= K:91 /\ 0 <= D100':93         /\ 0 <= i':92 /\ i':92 < param0:12)}Is not SAT! (Assertion on line 26 PASSED)---------------------------------------------================================================Bounds on Variables================================================Finished!"""

  private val test03 =
    """<Unique State Name, 74> -> <Unique State Name, 73>      Base relation: {when cond:69 = 0}       <Unique State Name, 74> -> <Unique State Name, 75>      Base relation: {when !(cond:69 = 0)}    <Unique State Name, 82> -> <Unique State Name, 65>  Base relation: {cond := param0:15}      <Unique State Name, 53> -> <Unique State Name, 47>      Base relation: {when k:7 < n:1} <Unique State Name, 53> -> <Unique State Name, 88>      Base relation: {return := havoc:22 return@pos := type_err:23 return@width := type_err:24 when n:1 <= k:7}   <Unique State Name, 75> -> <Unique State Name, 86>      Base relation: {return := havoc:70 return@pos := type_err:73 return@width := type_err:74}  <Unique State Name, 20> -> <Unique State Name, 5>        Base relation: {when m:3 <= j:2}        <Unique State Name, 20> -> <Unique State Name, 16>      Base relation: {D100 := (D100:4 + 1) j := (j:2 + 1) when j:2 < m:3}     <Unique State Name, 33> -> <Unique State Name, 90>  Base relation: {when (0 <= j___0:5 /\ 0 <= D100:4)}     <Unique State Name, 66> -> <Unique State Name, 87>      Base relation: {return := havoc:60 return@pos := type_err:63 return@width := type_err:64}   <Unique State Name, 91> -> <Unique State Name, 20>      Base relation: {}       <Unique State Name, 5> -> <Unique State Name, 92>       Base relation: {when (0 <= D100:4 /\ i:0 = 0 /\ i:0 = 0)}       <Unique State Name, 92> -> <Unique State Name, 9>   Base relation: {}       <Unique State Name, 64> -> <Unique State Name, 66>      Base relation: {when false}     <Unique State Name, 83> -> <Unique State Name, 5>       Base relation: {D100 := 0 i := 0 n := param0:15 m := param1:18 l := param2:21}      <Unique State Name, 73> -> <Unique State Name, 75>      Base relation: {when false}     <Unique State Name, 47> -> <Unique State Name, 89>      Base relation: {when (k:7 = 0 /\ 0 <= D100:4 /\ n:1 <= 0 /\ i:0 = 0 /\ k:7 = 0 /\ i:0 = 0)} <Unique State Name, 15> -> <Unique State Name, 16>      Base relation: {}       <Unique State Name, 37> -> <Unique State Name, 33>      Base relation: {D100 := (D100:4 + 1) j___0 := (j___0:5 + 1) when j___0:5 < l:6}     <Unique State Name, 37> -> <Unique State Name, 47>      Base relation: {k := 0 when l:6 <= j___0:5}     <Unique State Name, 9> -> <Unique State Name, 15>  Base relation: {D100 := 0 j := 0 when i:0 < n:1} <Unique State Name, 9> -> <Unique State Name, 33>       Base relation: {j___0 := 0 when n:1 <= i:0}     <Unique State Name, 88> -> <Unique State Name, >        Base relation: {}  <Unique State Name, 65> -> <Unique State Name, 64>       Base relation: {when cond:59 = 0}       <Unique State Name, 65> -> <Unique State Name, 66>      Base relation: {when !(cond:59 = 0)}    <Unique State Name, 89> -> <Unique State Name, 53>  Base relation: {D100 := (D100:4 + 1) i := (i:0 + 1)}    <Unique State Name, 90> -> <Unique State Name, 37>      Base relation: {}       <Unique State Name, 81> -> <Unique State Name, 74>      Base relation: {cond := param0:15}  <Unique State Name, 16> -> <Unique State Name, 91>      Base relation: {when (0 <= D100:4 /\ 0 <= j:2 /\ (-j:2 + D100:4) = 0)}  #################################################################           Beginning Interprocedural Anaylsis (with regexp=IRE)  Step 1: =========================================================Step 2: =========================================================Step 3: =========================================================        Converting to IRE regular expressions(Not performing widening.)alphaHatStar {**** body value: Base relation: {D100 := (D100:4 + 1) j := (j:2 + 1) when (0 <= D100:4 /\ 0 <= j:2 /\ (-j:2 + D100:4) = 0 /\ j:2 < m:3)}**** alpha hat:   {(j':80) = (1)*(j:2) + 1    (D100':79) = (1)*(j:2) + 1        pre:      [|-j:2+D100:4=0; -j:2+m:3-1>=0; j:2>=0|]    post:      [|-D100':79+j':80=0; -D100':79+m:3>=0; D100':79-1>=0|]}**** star transition:   {D100 := D100':79   j := j':80   when ((!(0 <= K:86) \/ j':80 = (j:2 + K:86))           /\ (!((0 <= K:86 /\ K:86 <= 0)) \/ D100':79 = (D100:4 + K:86))           /\ (!(1 <= K:86) \/ D100':79 = (j:2 + K:86))           /\ ((K:86 = 0 /\ j:2 = j':80 /\ D100:4 = D100':79)                 \/ (1 <= K:86 /\ (-j:2 + D100:4) = 0                       /\ 0 <= (-1 + -j:2 + m:3) /\ 0 <= j:2                       /\ (-D100':79 + j':80) = 0 /\ 0 <= (-D100':79 + m:3)                       /\ 0 <= (-1 + D100':79))) /\ 0 <= K:86)}}(Not performing widening.)alphaHatStar {**** body value: Base relation: {D100 := D100':89 j := j':88 when (0 <= D100:4 /\ i:0 = 0 /\ i:0 = 0 /\ i:0 < n:1         /\ (!(0 <= K:87) \/ j':88 = K:87)         /\ (!((0 <= K:87 /\ K:87 <= 0)) \/ D100':89 = K:87)         /\ (!(1 <= K:87) \/ D100':89 = K:87)         /\ ((K:87 = 0 /\ 0 = j':88 /\ 0 = D100':89)               \/ (1 <= K:87 /\ 0 <= (-1 + m:3) /\ (-D100':89 + j':88) = 0                     /\ 0 <= (-D100':89 + m:3) /\ 0 <= (-1 + D100':89)))         /\ 0 <= K:87 /\ 0 <= D100':89 /\ 0 <= j':88         /\ (-j':88 + D100':89) = 0 /\ m:3 <= j':88)}**** alpha hat:   {((D100':79 + -j':80)) = 0        pre:      [|i:0=0; n:1-1>=0; D100:4>=0|]    post:      [|-j':80+D100':79=0; i:0=0; n:1-1>=0; j':80-m:3>=0; j':80>=0|]}**** star transition:   {D100 := D100':79   j := j':80   when ((!((0 <= K:96 /\ K:96 <= 0))            \/ (D100':79 + -j':80) = (D100:4 + -j:2))           /\ (!(1 <= K:96) \/ (D100':79 + -j':80) = 0)           /\ ((K:96 = 0 /\ j:2 = j':80 /\ D100:4 = D100':79)                 \/ (1 <= K:96 /\ i:0 = 0 /\ 0 <= (-1 + n:1) /\ 0 <= D100:4                       /\ (-j':80 + D100':79) = 0 /\ i:0 = 0                       /\ 0 <= (-1 + n:1) /\ 0 <= (j':80 + -m:3)                       /\ 0 <= j':80)) /\ 0 <= K:96)}}(Not performing widening.)alphaHatStar {**** body value: Base relation: {D100 := (D100:4 + 1) j___0 := (j___0:5 + 1) when (0 <= j___0:5 /\ 0 <= D100:4 /\ j___0:5 < l:6)}**** alpha hat:   {(j___0':100) = (1)*(j___0:5) + 1    (D100':79) = (1)*(D100:4) + 1        pre:      [|-j___0:5+l:6-1>=0; D100:4>=0; j___0:5>=0|]    post:      [|-j___0':100+l:6>=0; D100':79-1>=0; j___0':100-1>=0|]}**** star transition:   {D100 := D100':79   j___0 := j___0':100   when ((!(0 <= K:106) \/ j___0':100 = (j___0:5 + K:106))           /\ (!(0 <= K:106) \/ D100':79 = (D100:4 + K:106))           /\ ((K:106 = 0 /\ j___0:5 = j___0':100 /\ D100:4 = D100':79)                 \/ (1 <= K:106 /\ 0 <= (-1 + -j___0:5 + l:6) /\ 0 <= D100:4                       /\ 0 <= j___0:5 /\ 0 <= (-j___0':100 + l:6)                       /\ 0 <= (-1 + D100':79) /\ 0 <= (-1 + j___0':100)))           /\ 0 <= K:106)}}(Not performing widening.)alphaHatStar {**** body value: Base relation: {D100 := (D100:4 + 1) i := (i:0 + 1) when (k:7 = 0 /\ 0 <= D100:4 /\ n:1 <= 0 /\ i:0 = 0 /\ k:7 = 0 /\ i:0 = 0         /\ k:7 < n:1)}**** alpha hat:   {    pre:      bottom    post:      bottom}**** star transition:   {D100 := D100':79   i := i':110   when (K:113 = 0 /\ i:0 = i':110 /\ D100:4 = D100':79 /\ 0 <= K:113)}}Step 4: =========================================================The procedure (i.e., variable) numbers are: 13  New-style (IRE) regular expression in IREregExpMap for reID=13: Weight(Base relation:   {D100 := (D100':116 + 1)   i := (i':115 + 1)   j := j':99   j___0 := j___0':108   k := 0   n := param0:15   m := param1:18   l := param2:21   return := havoc:117   return@pos := type_err:118   return@width := type_err:119   when ((!((0 <= K:97 /\ K:97 <= 0)) \/ (D100':98 + -j':99) = -j:2)           /\ (!(1 <= K:97) \/ (D100':98 + -j':99) = 0)           /\ ((K:97 = 0 /\ j:2 = j':99 /\ 0 = D100':98)                 \/ (1 <= K:97 /\ 0 <= (-1 + param0:15)                       /\ (-j':99 + D100':98) = 0 /\ 0 <= (-1 + param0:15)                       /\ 0 <= (j':99 + -param1:18) /\ 0 <= j':99))           /\ 0 <= K:97 /\ 0 <= D100':98 /\ param0:15 <= 0           /\ (!(0 <= K:107) \/ j___0':108 = K:107)           /\ (!(0 <= K:107) \/ D100':109 = (D100':98 + K:107))           /\ ((K:107 = 0 /\ 0 = j___0':108 /\ D100':98 = D100':109)                 \/ (1 <= K:107 /\ 0 <= (-1 + param2:21) /\ 0 <= D100':98                       /\ 0 <= (-j___0':108 + param2:21)                       /\ 0 <= (-1 + D100':109) /\ 0 <= (-1 + j___0':108)))           /\ 0 <= K:107 /\ 0 <= j___0':108 /\ 0 <= D100':109           /\ param2:21 <= j___0':108 /\ K:114 = 0 /\ 0 = i':115           /\ D100':109 = D100':116 /\ 0 <= K:114 /\ 0 <= D100':116           /\ param0:15 <= 0 /\ i':115 = 0 /\ i':115 = 0 /\ param0:15 <= 0)})Performing Gaussian Elimination.  ------------------------------ Working on variable 13  New-style (IRE) regular expression for 13 just before isolating it: Weight(Base relation:   {return := havoc:117   return@pos := type_err:118   return@width := type_err:119   when ((!((0 <= K:97 /\ K:97 <= 0)) \/ (D100':98 + -j':99) = -j:126)           /\ (!(1 <= K:97) \/ (D100':98 + -j':99) = 0)           /\ ((K:97 = 0 /\ j:126 = j':99 /\ 0 = D100':98)                 \/ (1 <= K:97 /\ 0 <= (-1 + param0:15)                       /\ (-j':99 + D100':98) = 0 /\ 0 <= (-1 + param0:15)                       /\ 0 <= (j':99 + -param1:18) /\ 0 <= j':99))           /\ 0 <= K:97 /\ 0 <= D100':98 /\ param0:15 <= 0           /\ (!(0 <= K:107) \/ j___0':108 = K:107)           /\ (!(0 <= K:107) \/ D100':109 = (D100':98 + K:107))           /\ ((K:107 = 0 /\ 0 = j___0':108 /\ D100':98 = D100':109)                 \/ (1 <= K:107 /\ 0 <= (-1 + param2:21) /\ 0 <= D100':98                       /\ 0 <= (-j___0':108 + param2:21)                       /\ 0 <= (-1 + D100':109) /\ 0 <= (-1 + j___0':108)))           /\ 0 <= K:107 /\ 0 <= j___0':108 /\ 0 <= D100':109           /\ param2:21 <= j___0':108 /\ K:114 = 0 /\ 0 = i':115           /\ D100':109 = D100':116 /\ 0 <= K:114 /\ 0 <= D100':116           /\ param0:15 <= 0 /\ i':115 = 0 /\ i':115 = 0 /\ param0:15 <= 0)}) ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  Finished Gaussian Elimination.New-style (IRE) regular expression in IREregExpsAfterIsolation for reID=13: Weight(Base relation:   {return := havoc:117   return@pos := type_err:118   return@width := type_err:119   when ((!((0 <= K:97 /\ K:97 <= 0)) \/ (D100':98 + -j':99) = -j:126)           /\ (!(1 <= K:97) \/ (D100':98 + -j':99) = 0)           /\ ((K:97 = 0 /\ j:126 = j':99 /\ 0 = D100':98)                 \/ (1 <= K:97 /\ 0 <= (-1 + param0:15)                       /\ (-j':99 + D100':98) = 0 /\ 0 <= (-1 + param0:15)                       /\ 0 <= (j':99 + -param1:18) /\ 0 <= j':99))           /\ 0 <= K:97 /\ 0 <= D100':98 /\ param0:15 <= 0           /\ (!(0 <= K:107) \/ j___0':108 = K:107)           /\ (!(0 <= K:107) \/ D100':109 = (D100':98 + K:107))           /\ ((K:107 = 0 /\ 0 = j___0':108 /\ D100':98 = D100':109)                 \/ (1 <= K:107 /\ 0 <= (-1 + param2:21) /\ 0 <= D100':98                       /\ 0 <= (-j___0':108 + param2:21)                       /\ 0 <= (-1 + D100':109) /\ 0 <= (-1 + j___0':108)))           /\ 0 <= K:107 /\ 0 <= j___0':108 /\ 0 <= D100':109           /\ param2:21 <= j___0':108 /\ K:114 = 0 /\ 0 = i':115           /\ D100':109 = D100':116 /\ 0 <= K:114 /\ 0 <= D100':116           /\ param0:15 <= 0 /\ i':115 = 0 /\ i':115 = 0 /\ param0:15 <= 0)})Step 5: =========================================================[Newton] Running Newton-------------------------------------------------------------------------------Round 0:Evaluating variable number 13 (using IRE)   The IRE-evaluated value on this round is: Base relation: {return := havoc:117 return@pos := type_err:118 return@width := type_err:119 when ((!((0 <= K:97 /\ K:97 <= 0)) \/ (D100':98 + -j':99) = -j:126)         /\ (!(1 <= K:97) \/ (D100':98 + -j':99) = 0)         /\ ((K:97 = 0 /\ j:126 = j':99 /\ 0 = D100':98)               \/ (1 <= K:97 /\ 0 <= (-1 + param0:15)                     /\ (-j':99 + D100':98) = 0 /\ 0 <= (-1 + param0:15)                     /\ 0 <= (j':99 + -param1:18) /\ 0 <= j':99))         /\ 0 <= K:97 /\ 0 <= D100':98 /\ param0:15 <= 0         /\ (!(0 <= K:107) \/ j___0':108 = K:107)         /\ (!(0 <= K:107) \/ D100':109 = (D100':98 + K:107))         /\ ((K:107 = 0 /\ 0 = j___0':108 /\ D100':98 = D100':109)               \/ (1 <= K:107 /\ 0 <= (-1 + param2:21) /\ 0 <= D100':98                     /\ 0 <= (-j___0':108 + param2:21)                     /\ 0 <= (-1 + D100':109) /\ 0 <= (-1 + j___0':108)))         /\ 0 <= K:107 /\ 0 <= j___0':108 /\ 0 <= D100':109         /\ param2:21 <= j___0':108 /\ K:114 = 0 /\ 0 = i':115         /\ D100':109 = D100':116 /\ 0 <= K:114 /\ 0 <= D100':116         /\ param0:15 <= 0 /\ i':115 = 0 /\ i':115 = 0 /\ param0:15 <= 0)}    (IRE-tc) Checking termination condition.    (IRE-tc)     >> All star bodies equivalent.NumRnds: 1Step 6: =========================================================##### Question automaton as FWPDS##### QUERY2WFA -  Initial State : __pstate  Q: {__pstate, __done}  F: {__done}    ( __pstate , accept , __done )       Base relation: {}Weights on states: __pstate 0x55cb752303f0:    Weight: Base relation: {when false}Accept: Base relation: {when false}__done 0x55cb7520cdd0:        Weight: Base relation: {when false}     Accept: Base relation: {}##### ANSWFA -  Initial State : __pstate  Q: {__pstate, __done}  F: {__done}    ( __pstate , accept , __done )     Base relation: {}Weights on states: __pstate 0x55cb7539e190:    Weight: Base relation: {when false}     Accept: Base relation: {when false}__done 0x55cb7539e2a0:       Weight: Base relation: {when false}     Accept: Base relation: {}================================================Procedure Summaries------------------------------------------------Procedure summary for mainBase relation: {D100 := (D100':116 + 1) i := (i':115 + 1) j := j':99 j___0 := j___0':108 k := 0 n := param0:15 m := param1:18 l := param2:21 return := havoc:117 return@pos := type_err:118 return@width := type_err:119 when ((!((0 <= K:97 /\ K:97 <= 0)) \/ (D100':98 + -j':99) = -j:2)         /\ (!(1 <= K:97) \/ (D100':98 + -j':99) = 0)         /\ ((K:97 = 0 /\ j:2 = j':99 /\ 0 = D100':98)               \/ (1 <= K:97 /\ 0 <= (-1 + param0:15)                     /\ (-j':99 + D100':98) = 0 /\ 0 <= (-1 + param0:15)                     /\ 0 <= (j':99 + -param1:18) /\ 0 <= j':99))         /\ 0 <= K:97 /\ 0 <= D100':98 /\ param0:15 <= 0         /\ (!(0 <= K:107) \/ j___0':108 = K:107)         /\ (!(0 <= K:107) \/ D100':109 = (D100':98 + K:107))         /\ ((K:107 = 0 /\ 0 = j___0':108 /\ D100':98 = D100':109)               \/ (1 <= K:107 /\ 0 <= (-1 + param2:21) /\ 0 <= D100':98                     /\ 0 <= (-j___0':108 + param2:21)                     /\ 0 <= (-1 + D100':109) /\ 0 <= (-1 + j___0':108)))         /\ 0 <= K:107 /\ 0 <= j___0':108 /\ 0 <= D100':109         /\ param2:21 <= j___0':108 /\ K:114 = 0 /\ 0 = i':115         /\ D100':109 = D100':116 /\ 0 <= K:114 /\ 0 <= D100':116         /\ param0:15 <= 0 /\ i':115 = 0 /\ i':115 = 0 /\ param0:15 <= 0)}================================================Assertion Checking at Error PointsChecking assertion at vertex 5, line 26Base relation: {when false}contextWeight = Base relation: {}intraproceduralWeight = Base relation: {D100 := 0 i := 0 j := 0 n := param0:15 m := param1:18 l := param2:21 when ((!((0 <= K:97 /\ K:97 <= 0)) \/ (D100':98 + -j':99) = -j:2)         /\ (!(1 <= K:97) \/ (D100':98 + -j':99) = 0)         /\ ((K:97 = 0 /\ j:2 = j':99 /\ 0 = D100':98)               \/ (1 <= K:97 /\ 0 <= (-1 + param0:15)                     /\ (-j':99 + D100':98) = 0 /\ 0 <= (-1 + param0:15)                     /\ 0 <= (j':99 + -param1:18) /\ 0 <= j':99))         /\ 0 <= K:97 /\ 0 <= D100':98 /\ 0 < param0:15)}*******************************************(declare-const j Int)(declare-const |j'| Int)(declare-const K Int)(declare-const |D100'| Int)(declare-const param1 Int)(declare-const param0 Int)(assert (and (or (not (and (<= 0 K) (<= K 0))) (= (+ |D100'| (- |j'|)) (- j)))               (or (not (<= 1 K)) (= (+ |D100'| (- |j'|)) 0))               (or (and (= K 0) (= j |j'|) (= 0 |D100'|))                     (and (<= 1 K) (<= 0 (+ -1 param0))                            (= (+ (- |j'|) |D100'|) 0) (<= 0 (+ -1 param0))                            (<= 0 (+ |j'| (- param1))) (<= 0 |j'|))) (<=                0 K) (<= 0 |D100'|) (< 0 param0)))(check-sat)contextWeight extend intraproceduralWeight = Base relation: {D100 := 0 i := 0 j := 0 n := param0:15 m := param1:18 l := param2:21 when ((!((0 <= K:97 /\ K:97 <= 0)) \/ (D100':98 + -j':99) = -j:2)         /\ (!(1 <= K:97) \/ (D100':98 + -j':99) = 0)         /\ ((K:97 = 0 /\ j:2 = j':99 /\ 0 = D100':98)               \/ (1 <= K:97 /\ 0 <= (-1 + param0:15)                     /\ (-j':99 + D100':98) = 0 /\ 0 <= (-1 + param0:15)                     /\ 0 <= (j':99 + -param1:18) /\ 0 <= j':99))         /\ 0 <= K:97 /\ 0 <= D100':98 /\ 0 < param0:15)}Is not SAT! (Assertion on line 26 PASSED)---------------------------------------------================================================Bounds on Variables================================================Finished!"""

  val parseIcraOutputRawInvariant: HashSet[TestCase] = {
    HashSet[TestCase](
      TestCase("Test01", test01, "RawInvariant(D100 := 0 i := (i':93 + 1) j := j':96 n := param0:12 m := param1:15,((!((0 <= K:91 /\\ K:91 <= 0)) \\/ D100':92 = 0)         /\\ (!(1 <= K:91) \\/ D100':92 = 0) /\\ (!(0 <= K:91) \\/ i':93 = K:91)         /\\ ((K:91 = 0 /\\ j:2 = j':94 /\\ 0 = i':93 /\\ 0 = D100':92)               \\/ (1 <= K:91 /\\ 0 <= (-1 + param0:12) /\\ D100':92 = 0                     /\\ 0 <= (-i':93 + param0:12)                     /\\ 0 <= (j':94 + -param1:15) /\\ 0 <= j':94                     /\\ 0 <= (-1 + i':93))) /\\ 0 <= K:91 /\\ D100':92 = 0         /\\ 0 <= i':93 /\\ D100':92 = 0 /\\ i':93 < param0:12         /\\ (!(0 <= K:95) \\/ j':96 = K:95)         /\\ (!((0 <= K:95 /\\ K:95 <= 0)) \\/ D100':97 = (D100':92 + K:95))         /\\ (!(1 <= K:95) \\/ D100':97 = K:95)         /\\ ((K:95 = 0 /\\ 0 = j':96 /\\ D100':92 = D100':97)               \\/ (1 <= K:95 /\\ D100':92 = 0 /\\ 0 <= (-1 + param1:15)                     /\\ (-D100':97 + j':96) = 0                     /\\ 0 <= (-D100':97 + param1:15) /\\ 0 <= (-1 + D100':97)))         /\\ 0 <= K:95 /\\ 0 <= D100':97 /\\ 0 <= j':96         /\\ (-j':96 + D100':97) = 0 /\\ param1:15 <= j':96))"),
      TestCase("Test02", test02, "RawInvariant(D100 := 0 i := i':92 j := j':94 n := param0:12 m := param1:15,((!(0 <= K:91) \\/ i':92 = K:91)         /\\ (!((0 <= K:91 /\\ K:91 <= 0)) \\/ (D100':93 + -j':94) = -j:2)         /\\ (!(1 <= K:91) \\/ (D100':93 + -j':94) = 0)         /\\ ((K:91 = 0 /\\ j:2 = j':94 /\\ 0 = i':92 /\\ 0 = D100':93)               \\/ (1 <= K:91 /\\ 0 <= (-1 + param0:12)                     /\\ (-j':94 + D100':93) = 0 /\\ 0 <= (-i':92 + param0:12)                     /\\ 0 <= (-1 + i':92) /\\ 0 <= (j':94 + -param1:15)                     /\\ 0 <= j':94)) /\\ 0 <= K:91 /\\ 0 <= D100':93         /\\ 0 <= i':92 /\\ i':92 < param0:12))"),
      TestCase("Test03", test03, "RawInvariant(D100 := 0 i := 0 j := 0 n := param0:15 m := param1:18 l := param2:21,((!((0 <= K:97 /\\ K:97 <= 0)) \\/ (D100':98 + -j':99) = -j:2)         /\\ (!(1 <= K:97) \\/ (D100':98 + -j':99) = 0)         /\\ ((K:97 = 0 /\\ j:2 = j':99 /\\ 0 = D100':98)               \\/ (1 <= K:97 /\\ 0 <= (-1 + param0:15)                     /\\ (-j':99 + D100':98) = 0 /\\ 0 <= (-1 + param0:15)                     /\\ 0 <= (j':99 + -param1:18) /\\ 0 <= j':99))         /\\ 0 <= K:97 /\\ 0 <= D100':98 /\\ 0 < param0:15))")
    )
  }

  val parseIcraOutputLexer: HashSet[TestCase] = {
    HashSet[TestCase](
      TestCase("Test01", test01,
        """List(D100, :=, 0, i, :=, (, i':93, +, 1, ), j, :=, j':96, n, :=, param0:12, m, :=, param1:15)
          |List((, (, !, (, (, 0, <=, K:91, /\, K:91, <=, 0, ), ), \/, D100':92, =, 0, ), /\, (, !, (, 1, <=, K:91, ), \/, D100':92, =, 0, ), /\, (, !, (, 0, <=, K:91, ), \/, i':93, =, K:91, ), /\, (, (, K:91, =, 0, /\, j:2, =, j':94, /\, 0, =, i':93, /\, 0, =, D100':92, ), \/, (, 1, <=, K:91, /\, 0, <=, (, -, 1, +, param0:12, ), /\, D100':92, =, 0, /\, 0, <=, (, -, i':93, +, param0:12, ), /\, 0, <=, (, j':94, +, -, param1:15, ), /\, 0, <=, j':94, /\, 0, <=, (, -, 1, +, i':93, ), ), ), /\, 0, <=, K:91, /\, D100':92, =, 0, /\, 0, <=, i':93, /\, D100':92, =, 0, /\, i':93, <, param0:12, /\, (, !, (, 0, <=, K:95, ), \/, j':96, =, K:95, ), /\, (, !, (, (, 0, <=, K:95, /\, K:95, <=, 0, ), ), \/, D100':97, =, (, D100':92, +, K:95, ), ), /\, (, !, (, 1, <=, K:95, ), \/, D100':97, =, K:95, ), /\, (, (, K:95, =, 0, /\, 0, =, j':96, /\, D100':92, =, D100':97, ), \/, (, 1, <=, K:95, /\, D100':92, =, 0, /\, 0, <=, (, -, 1, +, param1:15, ), /\, (, -, D100':97, +, j':96, ), =, 0, /\, 0, <=, (, -, D100':97, +, param1:15, ), /\, 0, <=, (, -, 1, +, D100':97, ), ), ), /\, 0, <=, K:95, /\, 0, <=, D100':97, /\, 0, <=, j':96, /\, (, -, j':96, +, D100':97, ), =, 0, /\, param1:15, <=, j':96, ))""".stripMargin),
      TestCase("Test02", test02,
        """List(D100, :=, 0, i, :=, i':92, j, :=, j':94, n, :=, param0:12, m, :=, param1:15)
          |List((, (, !, (, 0, <=, K:91, ), \/, i':92, =, K:91, ), /\, (, !, (, (, 0, <=, K:91, /\, K:91, <=, 0, ), ), \/, (, D100':93, +, -, j':94, ), =, -, j:2, ), /\, (, !, (, 1, <=, K:91, ), \/, (, D100':93, +, -, j':94, ), =, 0, ), /\, (, (, K:91, =, 0, /\, j:2, =, j':94, /\, 0, =, i':92, /\, 0, =, D100':93, ), \/, (, 1, <=, K:91, /\, 0, <=, (, -, 1, +, param0:12, ), /\, (, -, j':94, +, D100':93, ), =, 0, /\, 0, <=, (, -, i':92, +, param0:12, ), /\, 0, <=, (, -, 1, +, i':92, ), /\, 0, <=, (, j':94, +, -, param1:15, ), /\, 0, <=, j':94, ), ), /\, 0, <=, K:91, /\, 0, <=, D100':93, /\, 0, <=, i':92, /\, i':92, <, param0:12, ))""".stripMargin),
      TestCase("Test03", test03,
        """List(D100, :=, 0, i, :=, 0, j, :=, 0, n, :=, param0:15, m, :=, param1:18, l, :=, param2:21)
          |List((, (, !, (, (, 0, <=, K:97, /\, K:97, <=, 0, ), ), \/, (, D100':98, +, -, j':99, ), =, -, j:2, ), /\, (, !, (, 1, <=, K:97, ), \/, (, D100':98, +, -, j':99, ), =, 0, ), /\, (, (, K:97, =, 0, /\, j:2, =, j':99, /\, 0, =, D100':98, ), \/, (, 1, <=, K:97, /\, 0, <=, (, -, 1, +, param0:15, ), /\, (, -, j':99, +, D100':98, ), =, 0, /\, 0, <=, (, -, 1, +, param0:15, ), /\, 0, <=, (, j':99, +, -, param1:18, ), /\, 0, <=, j':99, ), ), /\, 0, <=, K:97, /\, 0, <=, D100':98, /\, 0, <, param0:15, ))""".stripMargin)
    )
  }

  val parseIcraOutputParser: HashSet[TestCase] = {
    HashSet[TestCase](
      TestCase("Test01", test01,
        """List(Assignment(Identifier(D100),Number(0)), Assignment(Identifier(i),Addition(Identifier(i':93),Number(1))), Assignment(Identifier(j),Identifier(j':96)), Assignment(Identifier(n),Identifier(param0:12)), Assignment(Identifier(m),Identifier(param1:15)))
          |And(Or(Negation(And(LessThanOrEqualTo(Number(0),Identifier(K:91)),LessThanOrEqualTo(Identifier(K:91),Number(0)))),Equal(Identifier(D100':92),Number(0))),And(Or(Negation(LessThanOrEqualTo(Number(1),Identifier(K:91))),Equal(Identifier(D100':92),Number(0))),And(Or(Negation(LessThanOrEqualTo(Number(0),Identifier(K:91))),Equal(Identifier(i':93),Identifier(K:91))),And(Or(And(Equal(Identifier(K:91),Number(0)),And(Equal(Identifier(j:2),Identifier(j':94)),And(Equal(Number(0),Identifier(i':93)),Equal(Number(0),Identifier(D100':92))))),And(LessThanOrEqualTo(Number(1),Identifier(K:91)),And(LessThanOrEqualTo(Number(0),Addition(Negative(Number(1)),Identifier(param0:12))),And(Equal(Identifier(D100':92),Number(0)),And(LessThanOrEqualTo(Number(0),Addition(Negative(Identifier(i':93)),Identifier(param0:12))),And(LessThanOrEqualTo(Number(0),Addition(Identifier(j':94),Negative(Identifier(param1:15)))),And(LessThanOrEqualTo(Number(0),Identifier(j':94)),LessThanOrEqualTo(Number(0),Addition(Negative(Number(1)),Identifier(i':93)))))))))),And(LessThanOrEqualTo(Number(0),Identifier(K:91)),And(Equal(Identifier(D100':92),Number(0)),And(LessThanOrEqualTo(Number(0),Identifier(i':93)),And(Equal(Identifier(D100':92),Number(0)),And(LessThan(Identifier(i':93),Identifier(param0:12)),And(Or(Negation(LessThanOrEqualTo(Number(0),Identifier(K:95))),Equal(Identifier(j':96),Identifier(K:95))),And(Or(Negation(And(LessThanOrEqualTo(Number(0),Identifier(K:95)),LessThanOrEqualTo(Identifier(K:95),Number(0)))),Equal(Identifier(D100':97),Addition(Identifier(D100':92),Identifier(K:95)))),And(Or(Negation(LessThanOrEqualTo(Number(1),Identifier(K:95))),Equal(Identifier(D100':97),Identifier(K:95))),And(Or(And(Equal(Identifier(K:95),Number(0)),And(Equal(Number(0),Identifier(j':96)),Equal(Identifier(D100':92),Identifier(D100':97)))),And(LessThanOrEqualTo(Number(1),Identifier(K:95)),And(Equal(Identifier(D100':92),Number(0)),And(LessThanOrEqualTo(Number(0),Addition(Negative(Number(1)),Identifier(param1:15))),And(Equal(Addition(Negative(Identifier(D100':97)),Identifier(j':96)),Number(0)),And(LessThanOrEqualTo(Number(0),Addition(Negative(Identifier(D100':97)),Identifier(param1:15))),LessThanOrEqualTo(Number(0),Addition(Negative(Number(1)),Identifier(D100':97))))))))),And(LessThanOrEqualTo(Number(0),Identifier(K:95)),And(LessThanOrEqualTo(Number(0),Identifier(D100':97)),And(LessThanOrEqualTo(Number(0),Identifier(j':96)),And(Equal(Addition(Negative(Identifier(j':96)),Identifier(D100':97)),Number(0)),LessThanOrEqualTo(Identifier(param1:15),Identifier(j':96)))))))))))))))))))""".stripMargin),
      TestCase("Test02", test02,
        """List(Assignment(Identifier(D100),Number(0)), Assignment(Identifier(i),Identifier(i':92)), Assignment(Identifier(j),Identifier(j':94)), Assignment(Identifier(n),Identifier(param0:12)), Assignment(Identifier(m),Identifier(param1:15)))
          |And(Or(Negation(LessThanOrEqualTo(Number(0),Identifier(K:91))),Equal(Identifier(i':92),Identifier(K:91))),And(Or(Negation(And(LessThanOrEqualTo(Number(0),Identifier(K:91)),LessThanOrEqualTo(Identifier(K:91),Number(0)))),Equal(Addition(Identifier(D100':93),Negative(Identifier(j':94))),Negative(Identifier(j:2)))),And(Or(Negation(LessThanOrEqualTo(Number(1),Identifier(K:91))),Equal(Addition(Identifier(D100':93),Negative(Identifier(j':94))),Number(0))),And(Or(And(Equal(Identifier(K:91),Number(0)),And(Equal(Identifier(j:2),Identifier(j':94)),And(Equal(Number(0),Identifier(i':92)),Equal(Number(0),Identifier(D100':93))))),And(LessThanOrEqualTo(Number(1),Identifier(K:91)),And(LessThanOrEqualTo(Number(0),Addition(Negative(Number(1)),Identifier(param0:12))),And(Equal(Addition(Negative(Identifier(j':94)),Identifier(D100':93)),Number(0)),And(LessThanOrEqualTo(Number(0),Addition(Negative(Identifier(i':92)),Identifier(param0:12))),And(LessThanOrEqualTo(Number(0),Addition(Negative(Number(1)),Identifier(i':92))),And(LessThanOrEqualTo(Number(0),Addition(Identifier(j':94),Negative(Identifier(param1:15)))),LessThanOrEqualTo(Number(0),Identifier(j':94))))))))),And(LessThanOrEqualTo(Number(0),Identifier(K:91)),And(LessThanOrEqualTo(Number(0),Identifier(D100':93)),And(LessThanOrEqualTo(Number(0),Identifier(i':92)),LessThan(Identifier(i':92),Identifier(param0:12)))))))))""".stripMargin),
      TestCase("Test03", test03,
        """List(Assignment(Identifier(D100),Number(0)), Assignment(Identifier(i),Number(0)), Assignment(Identifier(j),Number(0)), Assignment(Identifier(n),Identifier(param0:15)), Assignment(Identifier(m),Identifier(param1:18)), Assignment(Identifier(l),Identifier(param2:21)))
          |And(Or(Negation(And(LessThanOrEqualTo(Number(0),Identifier(K:97)),LessThanOrEqualTo(Identifier(K:97),Number(0)))),Equal(Addition(Identifier(D100':98),Negative(Identifier(j':99))),Negative(Identifier(j:2)))),And(Or(Negation(LessThanOrEqualTo(Number(1),Identifier(K:97))),Equal(Addition(Identifier(D100':98),Negative(Identifier(j':99))),Number(0))),And(Or(And(Equal(Identifier(K:97),Number(0)),And(Equal(Identifier(j:2),Identifier(j':99)),Equal(Number(0),Identifier(D100':98)))),And(LessThanOrEqualTo(Number(1),Identifier(K:97)),And(LessThanOrEqualTo(Number(0),Addition(Negative(Number(1)),Identifier(param0:15))),And(Equal(Addition(Negative(Identifier(j':99)),Identifier(D100':98)),Number(0)),And(LessThanOrEqualTo(Number(0),Addition(Negative(Number(1)),Identifier(param0:15))),And(LessThanOrEqualTo(Number(0),Addition(Identifier(j':99),Negative(Identifier(param1:18)))),LessThanOrEqualTo(Number(0),Identifier(j':99)))))))),And(LessThanOrEqualTo(Number(0),Identifier(K:97)),And(LessThanOrEqualTo(Number(0),Identifier(D100':98)),LessThan(Number(0),Identifier(param0:15)))))))""".stripMargin)
    )
  }

  val parserUnitTestBoolExpressions: HashSet[TestCase] = {
    HashSet[TestCase](
      TestCase("UnitIdentifier", unitIdentifier, "Identifier(j':99)"),
      TestCase("UnitBracket", unitBracket, "Identifier(D100':92)"),
      TestCase("UnitNegation", unitNegation, "Negation(Identifier(D100':92))"),
      TestCase("UnitLessThan", unitLessThan, "LessThan(Identifier(K:91),Identifier(i':92))"),
      TestCase("UnitLessThanOrEqualTo", unitLessThanOrEqualTo, "LessThanOrEqualTo(Identifier(K:91),Identifier(i':92))"),
      TestCase("UnitGreaterThan", unitGreaterThan, "GreaterThan(Identifier(K:91),Identifier(i':92))"),
      TestCase("UnitGreaterThanOrEqualTo", unitGreaterThanOrEqualTo, "GreaterThanOrEqualTo(Identifier(K:91),Identifier(i':92))"),
      TestCase("UnitEqual", unitEqual, "Equal(Identifier(K:91),Identifier(i':92))"),
      TestCase("UnitEqual2", unitEqual2, "Equal(Identifier(K:91),Negative(Identifier(i':92)))"),
      TestCase("UnitAnd", unitAnd, "And(Identifier(K:91),Identifier(i':92))"),
      TestCase("UnitOr", unitOr, "Or(Identifier(K:91),Identifier(i':92))")
    )
  }

  val parserIntegrationTestBoolExpressions: HashSet[TestCase] = {
    HashSet[TestCase](
      TestCase("IntegrationTest1", integrationTest1, "And(LessThanOrEqualTo(Number(0),Identifier(K:97)),LessThanOrEqualTo(Identifier(K:97),Number(0)))"),
      TestCase("IntegrationTest2", integrationTest2, "Negation(And(LessThanOrEqualTo(Number(0),Identifier(K:97)),LessThanOrEqualTo(Identifier(K:97),Number(0))))"),
      TestCase("IntegrationTest3", integrationTest3, "Or(Negation(And(LessThanOrEqualTo(Number(0),Identifier(K:97)),LessThanOrEqualTo(Identifier(K:97),Number(0)))),Equal(Addition(Identifier(D100':98),Negative(Identifier(j':99))),Negative(Identifier(j:2))))"),
      TestCase("IntegrationTest4", integrationTest4, "Or(Negation(LessThanOrEqualTo(Number(1),Identifier(K:97))),Equal(Addition(Identifier(D100':98),Negative(Identifier(j':99))),Number(0)))"),
      TestCase("IntegrationTest5", integrationTest5, "And(Equal(Identifier(K:97),Number(0)),And(Equal(Identifier(j:2),Identifier(j':99)),Equal(Number(0),Identifier(D100':98))))"),
      TestCase("IntegrationTest6", integrationTest6, "And(LessThanOrEqualTo(Number(1),Identifier(K:97)),LessThanOrEqualTo(Number(0),Addition(Negative(Number(1)),Identifier(param0:15))))"),
      TestCase("IntegrationTest7", integrationTest7, "And(Equal(Addition(Negative(Identifier(j':99)),Identifier(D100':98)),Number(0)),And(LessThanOrEqualTo(Number(0),Addition(Negative(Number(1)),Identifier(param0:15))),And(LessThanOrEqualTo(Number(0),Addition(Identifier(j':99),Negative(Identifier(param1:18)))),LessThanOrEqualTo(Number(0),Identifier(j':99)))))"),
      TestCase("IntegrationTest8", integrationTest8, "And(LessThanOrEqualTo(Number(0),Identifier(K:97)),And(LessThanOrEqualTo(Number(0),Identifier(D100':98)),LessThan(Number(0),Identifier(param0:15))))"),
      TestCase("IntegrationTest9", integrationTest9, "Equal(Addition(Identifier(D100':98),Negative(Identifier(j':99))),Negative(Identifier(j:2)))"),
      TestCase("IntegrationTest10", integrationTest10, "And(LessThan(Identifier(i:0),Identifier(n:1)),Or(And(LessThanOrEqualTo(Number(0),Identifier(m:4)),Equal(IfThenElse(LessThanOrEqualTo(Identifier(D100:3),Identifier(m:4)),Number(1),Number(0)),Identifier(phi_tmp:26))),And(LessThan(Identifier(m:4),Number(0)),Equal(Number(1),Identifier(phi_tmp:26)))))")
    )
  }

  val parserUnitTestArithmeticExpressions: HashSet[TestCase] = {
    HashSet[TestCase](
      TestCase("UnitIdentifier", unitIdentifier, "Identifier(j':99)"),
      TestCase("UnitNumber", unitNumber, "Number(145875)"),
      TestCase("UnitBracket", unitBracket, "Identifier(D100':92)"),
      TestCase("UnitNegative", unitNegative, "Negative(Identifier(D100':92))"),
      TestCase("UnitAddition", unitAddition, "Addition(Number(1),Identifier(i':92))"),
      TestCase("UnitSubtraction", unitSubtraction, "Subtraction(Identifier(K:91),Identifier(i':92))"),
      TestCase("UnitMultiplication", unitMultiplication, "Multiplication(Identifier(K:91),Identifier(i':92))"),
      TestCase("UnitDivision", unitDivision, "Division(Identifier(K:91),Identifier(i':92))"),
      TestCase("UnitIte", unitIte, "IfThenElse(Equal(Identifier(K:240),Number(0)),Number(1),Number(0))")
    )
  }

  val generateZ3ASTIntegerUnitTest: HashSet[TestCase] = {
    HashSet[TestCase](
      TestCase("", "j':99 + K:91", "(+ |j':99| |K:91|)"),
      TestCase("", "j':99 - K:91", "(- |j':99| |K:91|)"),
      TestCase("", "j':99 * K:91", "(* |j':99| |K:91|)"),
      TestCase("", "j':99 / K:91", "(div |j':99| |K:91|)"),
      TestCase("", "- K:91", "(- 0 |K:91|)"),
      TestCase("", "j':99 < K:91", "(< |j':99| |K:91|)"),
      TestCase("", "j':99 <= K:91", "(<= |j':99| |K:91|)"),
      TestCase("", "j':99 > K:91", "(> |j':99| |K:91|)"),
      TestCase("", "j':99 >= K:91", "(>= |j':99| |K:91|)"),
      TestCase("", "j':99 = K:91", "(= |j':99| |K:91|)")
    )
  }

  val generateZ3ASTBoolUnitTest: HashSet[TestCase] = {
    HashSet[TestCase](
      TestCase("", """(j':99 + 1 > 0) /\ (K:91 = 1)""", "(and (> (+ |j':99| 1) 0) (= |K:91| 1))"),
      TestCase("", """(j':99 + 1 > 0) \/ (K:91 = 1)""", "(or (> (+ |j':99| 1) 0) (= |K:91| 1))"),
      TestCase("", "! (K:91 = 1)", "(not (= |K:91| 1))"),
    )
  }
}